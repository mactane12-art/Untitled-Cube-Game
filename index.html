<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>untitled cube game â€” final</title>
<style>
  *{box-sizing:border-box}
  html,body{height:100%;width:100%;margin:0;padding:0;overflow:hidden;background:#111;font-family:Segoe UI, system-ui, -apple-system, "Helvetica Neue", Arial;color:#dfffdc}
  canvas{display:block;position:absolute;top:0;left:0}
  /* UI */
  #ui{position:fixed;top:12px;left:50%;transform:translateX(-50%);z-index:20;background:rgba(0,0,0,0.45);padding:8px 20px;border-radius:12px;font-weight:700;letter-spacing:1px;display:flex;gap:18px;align-items:center;backdrop-filter: blur(4px)}
  #ui.hidden{display:none}
  #pauseBtn{position:fixed;top:12px;right:12px;z-index:21;border:none;padding:10px 16px;border-radius:12px;background:linear-gradient(135deg,#222,#444);color:#9fff9f;cursor:pointer;font-weight:800;box-shadow:0 0 8px #0f0 inset}
  #pauseBtn:hover{background:linear-gradient(135deg,#0a0,#2b2);color:#071}
  /* joystick */
  #joystickContainer{position:fixed;left:22px;bottom:22px;width:120px;height:120px;border-radius:50%;background:rgba(255,255,255,0.06);z-index:22;display:none}
  #joystickBase{position:absolute;left:10px;top:10px;width:100px;height:100px;border-radius:50%;background:rgba(255,255,255,0.08)}
  #joystickThumb{position:absolute;width:50px;height:50px;border-radius:50%;left:35px;top:35px;background:rgba(255,255,255,0.7)}
  /* main menu */
  #mainMenu{position:fixed;inset:0;display:flex;gap:18px;align-items:center;justify-content:center;flex-direction:column;z-index:30;background:linear-gradient(180deg,#070a07 0%, #040504 100%)}
  #mainMenu h1{color:#9fff9f;font-size:46px;margin:0;text-shadow:0 0 18px rgba(20,255,20,0.08);letter-spacing:3px}
  .btn-row{display:flex;gap:16px}
  .diffBtn{padding:14px 26px;border-radius:12px;border:none;background:#1e3a1e;color:#dfffdc;font-weight:800;cursor:pointer;box-shadow:0 0 10px rgba(0,255,0,0.08)}
  .diffBtn:hover{transform:scale(1.04)}
  .diffBtn.selected{background:linear-gradient(135deg,#2f8 20%, #0b6 100%);box-shadow:0 0 28px rgba(0,255,170,0.12);transform:scale(1.08)}
  #playBtn{margin-top:8px;padding:14px 46px;border-radius:12px;border:none;background:linear-gradient(135deg,#08f,#06b);font-size:20px;color:#fff;cursor:pointer;box-shadow:0 0 20px rgba(0,180,255,0.12)}
  #playBtn:disabled{background:#333;cursor:default;box-shadow:none;opacity:0.6}
  #storeOpen{margin-top:6px;padding:8px 18px;border-radius:10px;border:none;background:#083;color:#dfffdc;cursor:pointer}
  /* death overlay flash & shake */
  #deathOverlay{position:fixed;inset:0;pointer-events:none;z-index:60;background:rgba(255,0,0,0);transition:background 0.08s linear}
  #deathOverlay.hit{background:rgba(255,0,0,0.18)}
  /* game over screen (death menu) */
  #deathMenu{position:fixed;inset:0;display:none;align-items:center;justify-content:center;flex-direction:column;background:rgba(0,0,0,0.9);z-index:120;color:#9fff9f;padding:20px}
  #deathMenu h2{font-size:42px;margin:6px 0}
  #deathMenu p{margin:6px 0;font-size:18px}
  .menuBtn{padding:12px 28px;margin:8px;border-radius:12px;border:none;background:linear-gradient(135deg,#0b6,#08f);color:#001;font-weight:800;cursor:pointer}
  .menuBtn.ghost{background:#333;color:#9fff9f}
  /* game over fade */
  .fade-in{animation:fadeIn 420ms ease forwards}
  @keyframes fadeIn{from{opacity:0}to{opacity:1}}
  /* store */
  #storeScreen{position:fixed;inset:0;display:none;flex-direction:column;padding:22px;background:linear-gradient(180deg,#061006,#040404);z-index:105;color:#9fff9f;gap:16px}
  #storeHeader{display:flex;justify-content:space-between;align-items:center}
  #itemsList{display:flex;gap:16px;flex-wrap:wrap;overflow:auto;padding:8px}
  .itemCard{width:180px;background:#0a120a;border-radius:12px;padding:12px;border:2px solid rgba(0,255,150,0.06);display:flex;flex-direction:column;align-items:center;gap:8px}
  .itemCard.owned{border-color:#0ff;box-shadow:0 0 18px rgba(0,255,255,0.05)}
  .itemCard .swatch{width:46px;height:46px;border-radius:8px}
  /* store close */
  #closeStore{padding:8px 16px;border-radius:10px;border:none;background:#073;color:#dfffdc;cursor:pointer}
  /* small responsive */
  @media(max-width:520px){ #mainMenu h1{font-size:30px} #playBtn{padding:12px 28px} #ui{font-size:14px;padding:6px 12px} }
</style>
</head>
<body>

<!-- MAIN MENU -->
<div id="mainMenu" role="dialog" aria-modal="true">
  <h1>untitled cube game</h1>
  <div class="btn-row" role="group" aria-label="difficulty choices">
    <button class="diffBtn" data-difficulty="easy">easy</button>
    <button class="diffBtn" data-difficulty="medium">medium</button>
    <button class="diffBtn" data-difficulty="hard">hard</button>
  </div>
  <button id="playBtn" disabled>play</button>
  <button id="openStore" class="storeBtn" style="margin-top:10px">store</button>
</div>

<!-- UI -->
<div id="ui" class="hidden" aria-live="polite">
  <div>health: <span id="health">50</span></div>
  <div>score: <span id="score">0</span></div>
  <div>coins: <span id="coins">0</span></div>
  <div>diff: <span id="difficultyText">easy</span></div>
</div>
<button id="pauseBtn" aria-pressed="false">pause</button>

<!-- Joystick -->
<div id="joystickContainer" aria-hidden="true">
  <div id="joystickBase"></div>
  <div id="joystickThumb"></div>
</div>

<!-- Canvas -->
<canvas id="gameCanvas" width="800" height="600" role="img" aria-label="game area"></canvas>

<!-- death flash overlay -->
<div id="deathOverlay" aria-hidden="true"></div>

<!-- Death menu (game over) -->
<div id="deathMenu" role="dialog" aria-modal="true">
  <h2>you died</h2>
  <p id="finalScore">score: 0</p>
  <p id="finalCoins">coins earned: 0</p>
  <div style="display:flex;gap:12px;margin-top:12px">
    <button id="restartBtn" class="menuBtn">restart</button>
    <button id="mainMenuBtn" class="menuBtn ghost">main menu</button>
  </div>
</div>

<!-- Store -->
<div id="storeScreen" role="dialog" aria-modal="true" aria-hidden="true">
  <div id="storeHeader">
    <h2>store</h2>
    <div style="display:flex;gap:12px;align-items:center">
      <div id="coinsDisplay">coins: 0</div>
      <button id="closeStore">close</button>
    </div>
  </div>
  <div id="itemsList"></div>
</div>

<script>
/* ----------------------------
   untitled cube final build
   - difficulty saved
   - harder hard mode + coin multipliers
   - player death shatter -> death menu (restart / main menu)
   - scaling with cap
   - store and persistence
   ---------------------------- */

(() => {
  // elements
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const ui = document.getElementById('ui');
  const healthSpan = document.getElementById('health');
  const scoreSpan = document.getElementById('score');
  const coinsSpan = document.getElementById('coins');
  const difficultyText = document.getElementById('difficultyText');
  const pauseBtn = document.getElementById('pauseBtn');
  const mainMenu = document.getElementById('mainMenu');
  const playBtn = document.getElementById('playBtn');
  const diffBtns = Array.from(document.querySelectorAll('.diffBtn'));
  const openStoreBtn = document.getElementById('openStore');
  const storeScreen = document.getElementById('storeScreen');
  const itemsList = document.getElementById('itemsList');
  const coinsDisplay = document.getElementById('coinsDisplay');
  const closeStore = document.getElementById('closeStore');
  const deathOverlay = document.getElementById('deathOverlay');
  const deathMenu = document.getElementById('deathMenu');
  const finalScore = document.getElementById('finalScore');
  const finalCoins = document.getElementById('finalCoins');
  const restartBtn = document.getElementById('restartBtn');
  const mainMenuBtn = document.getElementById('mainMenuBtn');
  const joystickContainer = document.getElementById('joystickContainer');
  const joystickThumb = document.getElementById('joystickThumb');

  // canvas size
  let W = window.innerWidth, H = window.innerHeight;
  function resize(){ W = window.innerWidth; H = window.innerHeight; canvas.width = W; canvas.height = H; }
  window.addEventListener('resize', resize);
  resize();

  // persistent storage keys
  const KEY_COINS = 'ucg_coins_v2';
  const KEY_OWNED = 'ucg_ownedSkins_v2';
  const KEY_SELECTED = 'ucg_selectedSkin_v2';
  const KEY_POWERUPS = 'ucg_ownedPowerups_v2';
  const KEY_DIFF = 'ucg_selectedDifficulty_v2';

  // game state
  let keys = {};
  let joystick = {x:0,y:0};
  let paused = false;
  let running = false;
  let difficulty = localStorage.getItem(KEY_DIFF) || 'easy';
  let score = 0;
  let coins = 0;
  let enemies = [];
  let particles = [];
  const MAX_PARTICLES = 100;
  let lastSpawn = 0;
  let lastScoreTick = 0;
  let spawnInterval = 2000; // overwritten by difficulty settings
  let scaleTimer = 0;
  let scaleStep = 0;
  let lastTime = 0;

  // player
  const player = {
    x:0,y:0,size:34,speed:3,maxHealth:50,health:50,color:'#0f0'
  };

  // death fragments
  let fragments = []; // when die

  // powerups/skins (store)
  const skins = [
    {id:'green', name:'green', price:0, color:'#0f0', desc:'default'},
    {id:'blue', name:'blue', price:40, color:'#08f', desc:'cool blue'},
    {id:'red', name:'red', price:60, color:'#f44', desc:'fiery red'},
    {id:'gold', name:'gold', price:120, color:'#ffcc33', desc:'shiny gold'},
  ];
  const powerups = [
    {id:'doubleScore', name:'double score', price:100, desc:'doubles score gain for 30s'}
  ];
  const storeItems = [...skins.map(s=>({type:'skin',...s})), ...powerups.map(p=>({type:'powerup',...p}))];

  // owned data
  let ownedSkins = [];
  let ownedPowerups = [];
  let selectedSkin = localStorage.getItem(KEY_SELECTED) || 'green';

  // difficulty settings
  const difficultySettings = {
    easy:   {spawnStart:2600, spawnMinCap:1400, speedMin:0.9, speedMax:1.5, scorePerSec:1, coinMul:1, scaleCapSpeed:1.6, scaleCapSpawn:1600},
    medium: {spawnStart:1800, spawnMinCap:900,  speedMin:1.4, speedMax:2.2, scorePerSec:2, coinMul:1.5, scaleCapSpeed:2.8, scaleCapSpawn:1000},
    hard:   {spawnStart:1000, spawnMinCap:450,  speedMin:2.2, speedMax:3.8, scorePerSec:3, coinMul:2, scaleCapSpeed:4.5, scaleCapSpawn:500}
  };

  // load persistence
  function loadAll(){
    coins = parseInt(localStorage.getItem(KEY_COINS) || '0',10);
    coins = Number.isNaN(coins) ? 0 : coins;
    ownedSkins = JSON.parse(localStorage.getItem(KEY_OWNED) || '["green"]');
    ownedPowerups = JSON.parse(localStorage.getItem(KEY_POWERUPS) || '[]');
    selectedSkin = localStorage.getItem(KEY_SELECTED) || 'green';
    const savedDiff = localStorage.getItem(KEY_DIFF);
    if(savedDiff) difficulty = savedDiff;
  }
  function saveAll(){
    localStorage.setItem(KEY_COINS, coins);
    localStorage.setItem(KEY_OWNED, JSON.stringify(ownedSkins));
    localStorage.setItem(KEY_POWERUPS, JSON.stringify(ownedPowerups));
    localStorage.setItem(KEY_SELECTED, selectedSkin);
    localStorage.setItem(KEY_DIFF, difficulty);
  }

  // init particles background
  function initParticles(){
    particles = [];
    for(let i=0;i<MAX_PARTICLES;i++){
      particles.push({x:Math.random()*W, y:Math.random()*H, size:1+Math.random()*3, speed:0.4+Math.random()*1});
    }
  }

  // spawn enemy from top
  function spawnEnemy(){
    const size = 20 + Math.random()*10;
    const x = Math.random()*(W - size);
    const settings = difficultySettings[difficulty];
    const min = settings.speedMin, max = settings.speedMax;
    // scale speed depending on scaleStep
    const scaleFactor = 1 + scaleStep*0.08; // small incremental
    let speed = min + Math.random()*(max-min);
    speed *= Math.min(scaleFactor, settings.scaleCapSpeed / max);
    enemies.push({x, y:-size, size, speed});
  }

  // movement
  function movePlayer(){
    let dx = 0, dy = 0;
    if(keys['w']||keys['arrowup']) dy -= 1;
    if(keys['s']||keys['arrowdown']) dy += 1;
    if(keys['a']||keys['arrowleft']) dx -= 1;
    if(keys['d']||keys['arrowright']) dx += 1;
    dx += joystick.x; dy += joystick.y;
    if(dx!==0||dy!==0){
      const len = Math.hypot(dx,dy);
      dx/=len; dy/=len;
      player.x += dx*player.speed;
      player.y += dy*player.speed;
    }
    // clamp
    player.x = Math.max(0,Math.min(W-player.size,player.x));
    player.y = Math.max(0,Math.min(H-player.size,player.y));
  }

  // enemy movement
  function moveEnemies(){
    for(let e of enemies) e.y += e.speed;
    enemies = enemies.filter(e => e.y < H + e.size);
  }

  // collisions
  let lastHitFlash = 0;
  function checkCollisions(){
    for(let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      if(rectsOverlap(player.x,player.y,player.size,player.size, e.x,e.y,e.size,e.size)){
        // hit
        enemies.splice(i,1);
        player.health -= 10;
        lastHitFlash = performance.now();
        deathOverlay.classList.add('hit');
        setTimeout(()=> deathOverlay.classList.remove('hit'), 120);
        // trigger small red flash (already done), if player dead -> trigger death sequence
        if(player.health <= 0){
          player.health = 0;
          triggerPlayerDeath();
          return;
        }
      }
    }
  }
  function rectsOverlap(x1,y1,w1,h1,x2,y2,w2,h2){
    return !(x2>w1+x1 || x2+w2 < x1 || y2 > y1+h1 || y2+h2 < y1);
  }

  // draw
  function draw(){
    ctx.clearRect(0,0,W,H);

    // background particles
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    for(let p of particles){
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.size,0,Math.PI*2);
      ctx.fill();
    }

    // draw enemies
    ctx.fillStyle = '#ff5b5b';
    for(let e of enemies) ctx.fillRect(e.x,e.y,e.size,e.size);

    // draw player (if alive)
    if(player.health>0){
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.size, player.size);
    }

    // draw fragments if dying
    if(fragments.length){
      for(let f of fragments){
        ctx.globalAlpha = f.alpha;
        ctx.fillStyle = f.color;
        ctx.fillRect(f.x - f.size/2, f.y - f.size/2, f.size, f.size);
        ctx.globalAlpha = 1;
      }
    }
  }

  // update particles
  function updateParticles(dt){
    for(let p of particles){
      p.x -= p.speed * dt * 0.06;
      if(p.x < -10){ p.x = W + 10; p.y = Math.random()*H; }
    }
  }

  // game loop
  function loop(ts){
    if(!lastTime) lastTime = ts;
    const dt = Math.min(50, ts - lastTime);
    lastTime = ts;
    if(running && !paused){
      // move + update
      movePlayer();
      moveEnemies();
      updateParticles(dt);
      checkCollisions();

      // spawn control
      if(ts - lastSpawn > spawnInterval){
        spawnEnemy(); lastSpawn = ts;
      }

      // scoring per second
      if(ts - lastScoreTick > 1000){
        lastScoreTick = ts;
        let base = difficultySettings[difficulty].scorePerSec;
        // if double score powerup active?
        if(activePowerups.doubleScore.active) base *= 2;
        score += base;
      }

      // scaling every 30s
      scaleTimer += dt;
      if(scaleTimer >= 30000){
        scaleTimer = 0;
        scaleStep++;
        // adjust spawnInterval slightly but respect min cap per difficulty
        const settings = difficultySettings[difficulty];
        const newSpawn = Math.max(settings.spawnMinCap, spawnInterval - Math.round( (settings.spawnStart - settings.spawnMinCap) * 0.06 ));
        spawnInterval = Math.max(settings.spawnMinCap, newSpawn);
      }

      // update fragments
      if(fragments.length){
        for(let f of fragments){
          f.vx += f.ax * (dt/16);
          f.vy += f.ay * (dt/16);
          f.x += f.vx * (dt/16);
          f.y += f.vy * (dt/16);
          f.alpha -= 0.02 * (dt/16);
        }
        fragments = fragments.filter(f => f.alpha > 0.02);
      }
    }

    // ui updates
    healthSpan.textContent = Math.max(0, Math.floor(player.health));
    scoreSpan.textContent = Math.floor(score);
    coinsSpan.textContent = Math.floor(coins);
    difficultyText.textContent = difficulty;

    draw();
    requestAnimationFrame(loop);
  }

  // death handling: shatter player into fragments, then show death menu
  function triggerPlayerDeath(){
    // create fragments only for player cube
    const cols = 6, rows = 6;
    const fragSize = Math.max(4, Math.floor(player.size / cols));
    fragments = [];
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const fx = player.x + c * fragSize + fragSize/2;
        const fy = player.y + r * fragSize + fragSize/2;
        // velocity outward from center
        const cx = player.x + player.size/2;
        const cy = player.y + player.size/2;
        const angle = Math.atan2(fy-cy, fx-cx) + (Math.random()*0.6 - 0.3);
        const speed = 2 + Math.random()*4;
        fragments.push({
          x: fx, y: fy, size: fragSize,
          vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed - (Math.random()*1.5),
          ax: 0, ay: 0.12, alpha: 1, color: player.color
        });
      }
    }

    // stop gameplay and freeze interactions briefly
    paused = true; running = false;

    // short delay for explosion animation then show death menu
    setTimeout(()=> {
      // compute coins earned using difficulty coin multiplier
      const coinMultiplier = difficultySettings[difficulty].coinMul;
      const coinsEarned = Math.floor((score / 10) * coinMultiplier);
      coins += coinsEarned;
      saveAll();

      finalScore.textContent = 'score: ' + Math.floor(score);
      finalCoins.textContent = 'coins earned: ' + coinsEarned;
      coinsSpan.textContent = coins;
      coinsDisplay.textContent = 'coins: ' + coins;

      // show death menu
      deathMenu.style.display = 'flex';
      deathMenu.classList.add('fade-in');
    }, 700);
  }

  // reset / start game
  function startGame(){
    // apply difficulty settings
    const settings = difficultySettings[difficulty];
    spawnInterval = settings.spawnStart;
    scaleTimer = 0; scaleStep = 0;
    lastSpawn = 0; lastScoreTick = performance.now();
    score = 0;
    enemies = [];
    initParticles();
    player.health = player.maxHealth;
    player.color = getSelectedSkinColor();
    player.x = W/2 - player.size/2; player.y = H/2 - player.size/2;
    fragments = [];
    paused = false; running = true; lastTime = 0;
    ui.classList.remove('hidden');
    pauseBtn.style.display = 'inline-block';
    requestAnimationFrame(loop);
  }

  // restart (same difficulty)
  function restartGame(){
    deathMenu.style.display = 'none';
    startGame();
  }

  // go to main menu
  function gotoMainMenu(){
    deathMenu.style.display = 'none';
    running = false; paused = false;
    ui.classList.add('hidden');
    pauseBtn.style.display = 'none';
    mainMenu.style.display = 'flex';
    // keep track of selected difficulty highlighted
  }

  // utility: get color for selected skin
  function getSelectedSkinColor(){
    const s = skins.find(x=>x.id===selectedSkin);
    return s ? s.color : '#0f0';
  }

  // store rendering & interactions
  function renderStore(){
    itemsList.innerHTML = '';
    coinsDisplay.textContent = 'coins: ' + coins;
    for(const item of storeItems){
      const card = document.createElement('div');
      card.className = 'itemCard';
      if(item.type === 'skin' && ownedSkins.includes(item.id)) card.classList.add('owned');
      card.innerHTML = `
        <div style="font-weight:800">${item.name}</div>
        ${item.type==='skin' ? `<div class="swatch" style="background:${item.color};margin:6px"></div>` : ''}
        <div style="font-size:13px;opacity:0.9;text-align:center">${item.desc}</div>
      `;
      const btn = document.createElement('button');
      if(item.type === 'skin'){
        if(ownedSkins.includes(item.id)){
          if(selectedSkin === item.id){ btn.textContent = 'selected'; btn.disabled=true; card.classList.add('selected'); }
          else{ btn.textContent = 'select'; btn.disabled=false; btn.onclick = ()=>{
            selectedSkin = item.id; localStorage.setItem(KEY_SELECTED, selectedSkin); renderStore();
          }}
        } else {
          btn.textContent = `buy (${item.price})`;
          btn.disabled = item.price > coins;
          btn.onclick = ()=>{ if(coins>=item.price){ coins-=item.price; ownedSkins.push(item.id); saveAll(); renderStore(); } };
        }
      } else {
        // powerup
        if(ownedPowerups.includes(item.id)){ btn.textContent = 'owned'; btn.disabled=true; }
        else{ btn.textContent = `buy (${item.price})`; btn.disabled = item.price > coins; btn.onclick = ()=>{ if(coins>=item.price){ coins-=item.price; ownedPowerups.push(item.id); saveAll(); renderStore(); } } }
      }
      card.appendChild(btn);
      itemsList.appendChild(card);
    }
  }

  // input handlers
  window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true );
  window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false );

  // joystick for mobile
  function setupJoystick(){
    if('ontouchstart' in window){
      joystickContainer.style.display = 'block';
      let dragging = false;
      let origin = {x:0,y:0}; const maxDist = 40;
      joystickContainer.addEventListener('touchstart', e=>{
        e.preventDefault();
        dragging = true;
        const rect = joystickContainer.getBoundingClientRect();
        origin.x = rect.left + rect.width/2;
        origin.y = rect.top + rect.height/2;
      });
      joystickContainer.addEventListener('touchmove', e=>{
        if(!dragging) return;
        e.preventDefault();
        const t = e.targetTouches[0];
        let dx = t.clientX - origin.x, dy = t.clientY - origin.y;
        const dist = Math.hypot(dx,dy);
        if(dist>maxDist){ dx = dx/dist*maxDist; dy = dy/dist*maxDist; }
        joystickThumb.style.left = (35 + dx) + 'px';
        joystickThumb.style.top = (35 + dy) + 'px';
        joystick.x = dx / maxDist; joystick.y = (dy / maxDist) * -1;
      });
      joystickContainer.addEventListener('touchend', e=>{
        dragging = false; joystickThumb.style.left='35px'; joystickThumb.style.top='35px'; joystick.x=0; joystick.y=0;
      });
    }
  }

  // difficulty selection UI
  function highlightDifficulty(){
    diffBtns.forEach(b=>{
      if(b.dataset.difficulty === difficulty){ b.classList.add('selected'); b.disabled=true; }
      else { b.classList.remove('selected'); b.disabled=false; }
    });
    playBtn.disabled = false;
    localStorage.setItem(KEY_DIFF, difficulty);
  }

  // on diff button click
  diffBtns.forEach(b=>{
    b.addEventListener('click', ()=>{
      difficulty = b.dataset.difficulty;
      highlightDifficulty();
    });
  });

  // play button
  playBtn.addEventListener('click', ()=>{
    mainMenu.style.display = 'none';
    ui.classList.remove('hidden');
    pauseBtn.style.display = 'inline-block';
    setupJoystick();
    startGame();
  });

  // store open/close
  openStoreBtn.addEventListener('click', ()=>{
    mainMenu.style.display = 'none';
    renderStore();
    storeScreen.style.display = 'flex';
  });
  closeStore.addEventListener('click', ()=>{
    storeScreen.style.display = 'none';
    mainMenu.style.display = 'flex';
  });

  // death menu buttons
  restartBtn.addEventListener('click', ()=> { deathMenu.style.display='none'; startGame(); });
  mainMenuBtn.addEventListener('click', ()=> { deathMenu.style.display='none'; gotoMainMenu(); });

  // pause
  pauseBtn.addEventListener('click', ()=> {
    paused = !paused;
    pauseBtn.textContent = paused ? 'resume' : 'pause';
  });

  // save state periodically
  setInterval(()=> saveAll(), 2000);

  // init loads
  loadAll();
  highlightDifficulty();
  initParticles();
  setupJoystick();
  // ensure ui reflects coins
  coinsSpan.textContent = coins;
  coinsDisplay.textContent = 'coins: ' + coins;

  // persist owned arrays if empty defaults
  if(!ownedSkins || !ownedSkins.length){ ownedSkins = ['green']; saveAll(); }

  // start rendering loop but not gameplay
  requestAnimationFrame(loop);

  // expose some helpers to console for quick testing (optional)
  window._ucg = { coins, ownedSkins, selectedSkin, difficulty };
})();
</script>

</body>
</html>
