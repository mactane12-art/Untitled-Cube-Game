<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>untitled cube game restored UI + fixes</title>
  <style>
    /* restored original UI style and basic resets */
    * {
      box-sizing: border-box;
    }
    body,
    html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
      color: #0f0;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      user-select: none;
      height: 100%;
      width: 100%;
    }
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      background: #111;
    }
    /* UI container */
    #ui {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #0f0;
      font-weight: 700;
      font-size: 18px;
      line-height: 1.4;
      text-shadow: 0 0 4px #0f0a0f;
      user-select: none;
      z-index: 100;
      background: rgba(0, 50, 0, 0.6);
      border-radius: 10px;
      padding: 8px 16px;
      min-width: 130px;
      font-variant-numeric: tabular-nums;
      display: none;
    }
    #ui > div {
      margin-bottom: 6px;
    }
    #pauseBtn {
      position: fixed;
      top: 10px;
      right: 10px;
      background: #0a0;
      border: none;
      padding: 10px 18px;
      font-weight: 700;
      font-size: 16px;
      color: #030;
      border-radius: 12px;
      box-shadow: 0 0 12px #0f0 inset;
      cursor: pointer;
      z-index: 101;
      user-select: none;
      transition: background-color 0.3s ease;
      display: none;
    }
    #pauseBtn:hover {
      background: #0f0;
      color: #060;
    }
    /* joystick */
    #joystickContainer {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: rgba(255 255 255 / 0.06);
      display: none;
      user-select: none;
      z-index: 102;
    }
    #joystickBase {
      position: absolute;
      left: 10px;
      top: 10px;
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: rgba(255 255 255 / 0.08);
    }
    #joystickThumb {
      position: absolute;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      left: 35px;
      top: 35px;
      background: rgba(255 255 255 / 0.7);
      transition: left 0.1s ease, top 0.1s ease;
    }
    /* main menu */
    #mainMenu {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: linear-gradient(180deg, #070a07 0%, #040504 100%);
      color: #9fff9f;
      font-weight: 900;
      letter-spacing: 3px;
      user-select: none;
      z-index: 110;
    }
    #mainMenu h1 {
      font-size: 52px;
      margin-bottom: 30px;
      text-shadow: 0 0 15px rgba(20, 255, 20, 0.08);
    }
    .btn-row {
      display: flex;
      gap: 18px;
      margin-bottom: 24px;
    }
    .diffBtn {
      background: #1e3a1e;
      color: #dfffdc;
      border-radius: 12px;
      border: none;
      font-weight: 900;
      font-size: 22px;
      padding: 14px 34px;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.08);
      transition: transform 0.15s ease, background 0.15s ease;
    }
    .diffBtn:hover {
      transform: scale(1.04);
    }
    .diffBtn.selected {
      background: linear-gradient(135deg, #2f8 20%, #0b6 100%);
      box-shadow: 0 0 28px rgba(0, 255, 170, 0.12);
      transform: scale(1.1);
      color: #060;
    }
    #playBtn {
      font-weight: 900;
      font-size: 26px;
      background: linear-gradient(135deg, #08f, #06b);
      color: #fff;
      border-radius: 12px;
      border: none;
      padding: 14px 48px;
      cursor: pointer;
      box-shadow: 0 0 20px rgba(0, 180, 255, 0.15);
      transition: background 0.3s ease;
    }
    #playBtn:disabled {
      background: #333;
      cursor: default;
      opacity: 0.6;
      box-shadow: none;
    }
    #openStore {
      margin-top: 12px;
      background: #083;
      border-radius: 10px;
      border: none;
      color: #dfffdc;
      cursor: pointer;
      font-weight: 700;
      padding: 8px 20px;
      box-shadow: 0 0 12px #0f0;
      user-select: none;
    }
    #openStore:hover {
      background: #0a5;
    }
    /* death overlay red flash */
    #deathOverlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 120;
      background: rgba(255, 0, 0, 0);
      transition: background 0.08s linear;
    }
    #deathOverlay.hit {
      background: rgba(255, 0, 0, 0.16);
    }
    /* death menu */
    #deathMenu {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      color: #9fff9f;
      font-weight: 700;
      font-size: 20px;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 12px;
      z-index: 125;
      user-select: none;
      letter-spacing: 1px;
    }
    #deathMenu h2 {
      font-size: 48px;
      margin: 0;
    }
    #deathMenu p {
      margin: 0;
    }
    .menuBtn {
      font-weight: 700;
      font-size: 22px;
      cursor: pointer;
      padding: 14px 40px;
      border-radius: 12px;
      border: none;
      background: linear-gradient(135deg, #0b6, #08f);
      color: #001;
      box-shadow: 0 0 20px rgba(0, 180, 255, 0.2);
      transition: background 0.3s ease;
    }
    .menuBtn.ghost {
      background: #333;
      color: #9fff9f;
      box-shadow: none;
    }
    .menuBtn:hover:not(:disabled) {
      background: linear-gradient(135deg, #06b, #08f);
    }
    /* store */
    #storeScreen {
      position: fixed;
      inset: 0;
      background: linear-gradient(180deg, #061006, #040404);
      color: #9fff9f;
      display: none;
      flex-direction: column;
      padding: 24px;
      gap: 16px;
      z-index: 130;
      user-select: none;
    }
    #storeHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 700;
      font-size: 22px;
    }
    #coinsDisplay {
      font-weight: 700;
      font-size: 20px;
      color: #0f0;
      text-shadow: 0 0 8px #0f0;
    }
    #itemsList {
      display: flex;
      flex-wrap: wrap;
      gap: 18px;
      overflow-y: auto;
      max-height: 65vh;
      margin-top: 8px;
    }
    .itemCard {
      background: #0a120a;
      border-radius: 12px;
      border: 2px solid rgba(0, 255, 150, 0.06);
      width: 180px;
      padding: 14px 10px 18px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      box-sizing: border-box;
      color: #9fff9f;
      user-select: none;
    }
    .itemCard.owned {
      border-color: #0ff;
      box-shadow: 0 0 18px rgba(0, 255, 255, 0.05);
    }
    .itemCard.selected {
      box-shadow: 0 0 30px #0f0 inset;
      border-color: #0f0;
    }
    .swatch {
      width: 46px;
      height: 46px;
      border-radius: 8px;
      border: 1px solid rgba(255 255 255 / 0.1);
      box-shadow: 0 0 8px rgba(0, 255, 0, 0.15);
    }
    .itemCard > button {
      background: #062806;
      border: none;
      border-radius: 10px;
      padding: 8px 20px;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      color: #9fff9f;
      box-shadow: 0 0 10px #0f0 inset;
      user-select: none;
      transition: background 0.2s ease;
      width: 100%;
    }
    .itemCard > button:disabled {
      opacity: 0.45;
      cursor: default;
      box-shadow: none;
    }
    .itemCard > button:hover:not(:disabled) {
      background: #0f0;
      color: #030;
    }
    #closeStore {
      background: #073;
      border-radius: 12px;
      border: none;
      padding: 10px 22px;
      font-weight: 700;
      font-size: 20px;
      cursor: pointer;
      box-shadow: 0 0 18px #0f0 inset;
      color: #9fff9f;
      user-select: none;
      align-self: flex-end;
      margin-bottom: 6px;
      transition: background 0.2s ease;
    }
    #closeStore:hover {
      background: #0a5;
    }

    /* fade in class */
    .fade-in {
      animation: fadeIn 420ms ease forwards;
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    /* Responsive adjustments */
    @media (max-width: 520px) {
      #mainMenu h1 {
        font-size: 32px;
      }
      .diffBtn {
        font-size: 18px;
        padding: 12px 26px;
      }
      #playBtn {
        font-size: 20px;
        padding: 12px 34px;
      }
      #ui {
        font-size: 14px;
        padding: 6px 14px;
      }
    }
  </style>
</head>
<body>
  <!-- MAIN MENU -->
  <div id="mainMenu" role="dialog" aria-modal="true">
    <h1>untitled cube game</h1>
    <div class="btn-row" role="group" aria-label="difficulty choices">
      <button class="diffBtn" data-difficulty="easy">easy</button>
      <button class="diffBtn" data-difficulty="medium">medium</button>
      <button class="diffBtn" data-difficulty="hard">hard</button>
    </div>
    <button id="playBtn" disabled>play</button>
    <button id="openStore" class="storeBtn">store</button>
  </div>

  <!-- UI -->
  <div id="ui" aria-live="polite" aria-atomic="true">
    <div>health: <span id="health">50</span></div>
    <div>score: <span id="score">0</span></div>
    <div>coins: <span id="coins">0</span></div>
    <div>diff: <span id="difficultyText">easy</span></div>
  </div>
  <button id="pauseBtn" aria-pressed="false">pause</button>

  <!-- Joystick -->
  <div id="joystickContainer" aria-hidden="true">
    <div id="joystickBase"></div>
    <div id="joystickThumb"></div>
  </div>

  <!-- Canvas -->
  <canvas id="gameCanvas" width="800" height="600" role="img" aria-label="game area"></canvas>

  <!-- death flash overlay -->
  <div id="deathOverlay" aria-hidden="true"></div>

  <!-- Death menu -->
  <div id="deathMenu" role="dialog" aria-modal="true">
    <h2>you died</h2>
    <p id="finalScore">score: 0</p>
    <p id="finalCoins">coins earned: 0</p>
    <div style="display:flex;gap:12px;margin-top:12px">
      <button id="restartBtn" class="menuBtn">restart</button>
      <button id="mainMenuBtn" class="menuBtn ghost">main menu</button>
    </div>
  </div>

  <!-- Store -->
  <div id="storeScreen" role="dialog" aria-modal="true" aria-hidden="true">
    <div id="storeHeader">
      <h2>store</h2>
      <div style="display:flex;gap:12px;align-items:center">
        <div id="coinsDisplay">coins: 0</div>
        <button id="closeStore">close</button>
      </div>
    </div>
    <div id="itemsList"></div>
  </div>

  <script>
    (() => {
      // elements
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const ui = document.getElementById("ui");
      const healthSpan = document.getElementById("health");
      const scoreSpan = document.getElementById("score");
      const coinsSpan = document.getElementById("coins");
      const difficultyText = document.getElementById("difficultyText");
      const pauseBtn = document.getElementById("pauseBtn");
      const mainMenu = document.getElementById("mainMenu");
      const playBtn = document.getElementById("playBtn");
      const diffBtns = Array.from(document.querySelectorAll(".diffBtn"));
      const openStoreBtn = document.getElementById("openStore");
      const storeScreen = document.getElementById("storeScreen");
      const itemsList = document.getElementById("itemsList");
      const coinsDisplay = document.getElementById("coinsDisplay");
      const closeStore = document.getElementById("closeStore");
      const deathOverlay = document.getElementById("deathOverlay");
      const deathMenu = document.getElementById("deathMenu");
      const finalScore = document.getElementById("finalScore");
      const finalCoins = document.getElementById("finalCoins");
      const restartBtn = document.getElementById("restartBtn");
      const mainMenuBtn = document.getElementById("mainMenuBtn");
      const joystickContainer = document.getElementById("joystickContainer");
      const joystickThumb = document.getElementById("joystickThumb");

      // canvas size
      let W = window.innerWidth,
        H = window.innerHeight;
      function resize() {
        W = window.innerWidth;
        H = window.innerHeight;
        canvas.width = W;
        canvas.height = H;
      }
      window.addEventListener("resize", resize);
      resize();

      // persistent storage keys
      const KEY_COINS = "ucg_coins_v2";
      const KEY_OWNED = "ucg_ownedSkins_v2";
      const KEY_SELECTED = "ucg_selectedSkin_v2";
      const KEY_POWERUPS = "ucg_ownedPowerups_v2";
      const KEY_DIFF = "ucg_selectedDifficulty_v2";

      // game state
      let keys = {};
      let joystick = { x: 0, y: 0 };
      let paused = false;
      let running = false;
      let difficulty = localStorage.getItem(KEY_DIFF) || "easy";
      let score = 0;
      let coins = 0;
      let enemies = [];
      let particles = [];
      const MAX_PARTICLES = 100;
      let lastSpawn = 0;
      let lastScoreTick = 0;
      let spawnInterval = 2000; // overwritten by difficulty settings
      let scaleTimer = 0;
      let scaleStep = 0;
      let lastTime = 0;

      // player
      const player = {
        x: 0,
        y: 0,
        size: 34,
        speed: 3,
        maxHealth: 50,
        health: 50,
        color: "#0f0",
      };

      // death fragments
      let fragments = []; // when die

      // powerups/skins (store)
      const skins = [
        { id: "green", name: "green", price: 0, color: "#0f0", desc: "default" },
        { id: "red", name: "red", price: 300, color: "#f00", desc: "fiery cube" },
        { id: "blue", name: "blue", price: 500, color: "#06f", desc: "cool blue" },
      ];

      // powerups increase coins per score multiplier or health
      const powerups = [
        { id: "hpUp", name: "extra health", price: 800, desc: "adds +20 max health" },
        { id: "coinBoost", name: "coin boost", price: 1200, desc: "coins x2" },
      ];

      // user owned stuff
      let ownedSkins = JSON.parse(localStorage.getItem(KEY_OWNED)) || ["green"];
      let selectedSkin = localStorage.getItem(KEY_SELECTED) || "green";
      let ownedPowerups = JSON.parse(localStorage.getItem(KEY_POWERUPS)) || [];

      // difficulty settings
      const difficulties = {
        easy: { spawn: 2500, enemySpeed: 1.5, scorePerSec: 1, healthMult: 1, coinMult: 1 },
        medium: { spawn: 1800, enemySpeed: 2.6, scorePerSec: 2, healthMult: 0.85, coinMult: 1.3 },
        hard: { spawn: 1100, enemySpeed: 3.9, scorePerSec: 3.6, healthMult: 0.7, coinMult: 1.8 },
      };

      // joystick state
      let joystickActive = false;
      let joystickOrigin = { x: 0, y: 0 };
      let joystickPos = { x: 0, y: 0 };

      // limit max hits to 5 before death
      const MAX_HITS = 5;

      // helper funcs
      function clamp(val, min, max) {
        return val < min ? min : val > max ? max : val;
      }
      function rectsCollide(r1, r2) {
        return (
          r1.x < r2.x + r2.size &&
          r1.x + r1.size > r2.x &&
          r1.y < r2.y + r2.size &&
          r1.y + r1.size > r2.y
        );
      }
      function saveGame() {
        localStorage.setItem(KEY_COINS, coins);
        localStorage.setItem(KEY_OWNED, JSON.stringify(ownedSkins));
        localStorage.setItem(KEY_SELECTED, selectedSkin);
        localStorage.setItem(KEY_POWERUPS, JSON.stringify(ownedPowerups));
        localStorage.setItem(KEY_DIFF, difficulty);
      }
      function loadGame() {
        coins = Number(localStorage.getItem(KEY_COINS)) || 0;
        ownedSkins = JSON.parse(localStorage.getItem(KEY_OWNED)) || ["green"];
        selectedSkin = localStorage.getItem(KEY_SELECTED) || "green";
        ownedPowerups = JSON.parse(localStorage.getItem(KEY_POWERUPS)) || [];
        difficulty = localStorage.getItem(KEY_DIFF) || "easy";
      }
      function pickSkinColor(id) {
        let s = skins.find((sk) => sk.id === id);
        return s ? s.color : "#0f0";
      }
      function hasPowerup(id) {
        return ownedPowerups.includes(id);
      }

      // apply powerup bonuses
      function maxPlayerHealth() {
        let base = 50;
        if (hasPowerup("hpUp")) base += 20;
        return base;
      }
      function coinMultiplier() {
        return hasPowerup("coinBoost") ? 2 : 1;
      }

      // enemies spawn top-down, move downward
      function spawnEnemy() {
        enemies.push({
          x: Math.random() * (W - 30),
          y: -40,
          size: 28 + Math.random() * 10,
          speed: difficulties[difficulty].enemySpeed,
          color: "#f00",
        });
      }

      // particles float left with 50% transparency
      function spawnParticle() {
        if (particles.length >= MAX_PARTICLES) return;
        particles.push({
          x: Math.random() * W,
          y: Math.random() * H,
          size: 3 + Math.random() * 3,
          speedX: -0.25 - Math.random() * 0.25,
          alpha: 0.5,
        });
      }

      // create death fragments for player (just the player)
      function createFragments() {
        fragments = [];
        const fragCount = 14;
        for (let i = 0; i < fragCount; i++) {
          fragments.push({
            x: player.x + player.size / 2,
            y: player.y + player.size / 2,
            size: 6 + Math.random() * 4,
            vx: (Math.random() - 0.5) * 6,
            vy: (Math.random() - 0.5) * 6,
            life: 60 + Math.random() * 20,
            alpha: 1,
            color: pickSkinColor(selectedSkin),
          });
        }
      }

      // draw fragments
      function drawFragments() {
        for (let f of fragments) {
          ctx.fillStyle = `rgba(${parseInt(f.color.slice(1,3),16)},${parseInt(f.color.slice(3,5),16)},${parseInt(f.color.slice(5,7),16)},${f.alpha.toFixed(2)})`;
          ctx.fillRect(f.x, f.y, f.size, f.size);
        }
      }

      // update fragments
      function updateFragments() {
        for (let i = fragments.length - 1; i >= 0; i--) {
          let f = fragments[i];
          f.x += f.vx;
          f.y += f.vy;
          f.vx *= 0.92;
          f.vy *= 0.92;
          f.life--;
          f.alpha -= 0.02;
          if (f.life <= 0 || f.alpha <= 0) fragments.splice(i, 1);
        }
      }

      // draw player
      function drawPlayer() {
        ctx.fillStyle = pickSkinColor(selectedSkin);
        ctx.fillRect(player.x, player.y, player.size, player.size);
      }

      // draw enemies
      function drawEnemies() {
        enemies.forEach((e) => {
          ctx.fillStyle = e.color;
          ctx.fillRect(e.x, e.y, e.size, e.size);
        });
      }

      // draw particles
      function drawParticles() {
        particles.forEach((p) => {
          ctx.fillStyle = `rgba(255,255,255,${p.alpha})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      // update enemies
      function updateEnemies() {
        for (let i = enemies.length - 1; i >= 0; i--) {
          let e = enemies[i];
          e.y += e.speed;
          if (e.y > H + e.size) {
            enemies.splice(i, 1);
            continue;
          }
          // check collision with player
          if (
            rectsCollide(
              { x: player.x, y: player.y, size: player.size },
              e
            )
          ) {
            enemies.splice(i, 1);
            player.health--;
            showDeathFlash();
            if (player.health <= 0) {
              onPlayerDeath();
            }
          }
        }
      }

      // update particles
      function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
          let p = particles[i];
          p.x += p.speedX;
          if (p.x + p.size < 0) {
            particles.splice(i, 1);
            continue;
          }
        }
      }

      // show death red flash
      let deathFlashTimeout = null;
      function showDeathFlash() {
        deathOverlay.classList.add("hit");
        clearTimeout(deathFlashTimeout);
        deathFlashTimeout = setTimeout(() => {
          deathOverlay.classList.remove("hit");
        }, 80);
      }

      // joystick handlers
      function setupJoystick() {
        joystickContainer.style.display = "block";

        function touchStart(e) {
          if (e.touches.length === 1) {
            joystickActive = true;
            joystickOrigin.x = e.touches[0].clientX;
            joystickOrigin.y = e.touches[0].clientY;
            joystickPos.x = joystickOrigin.x;
            joystickPos.y = joystickOrigin.y;
            moveThumb(0, 0);
          }
        }
        function touchMove(e) {
          if (!joystickActive) return;
          e.preventDefault();
          const touch = e.touches[0];
          let dx = touch.clientX - joystickOrigin.x;
          let dy = touch.clientY - joystickOrigin.y;
          const maxDist = 50;
          const dist = Math.min(maxDist, Math.sqrt(dx * dx + dy * dy));
          const angle = Math.atan2(dy, dx);
          dx = Math.cos(angle) * dist;
          dy = Math.sin(angle) * dist;
          joystick.x = dx / maxDist;
          joystick.y = dy / maxDist;
          moveThumb(dx, dy);
        }
        function touchEnd(e) {
          joystickActive = false;
          joystick.x = 0;
          joystick.y = 0;
          moveThumb(0, 0);
        }

        joystickContainer.addEventListener("touchstart", touchStart);
        joystickContainer.addEventListener("touchmove", touchMove, { passive: false });
        joystickContainer.addEventListener("touchend", touchEnd);
        joystickContainer.addEventListener("touchcancel", touchEnd);

        function moveThumb(x, y) {
          joystickThumb.style.left = `${35 + x}px`;
          joystickThumb.style.top = `${35 + y}px`;
        }
      }

      // hide joystick for desktop, show for mobile
      function checkMobile() {
        if (/Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
          setupJoystick();
          joystickContainer.style.display = "block";
        } else {
          joystickContainer.style.display = "none";
        }
      }
      checkMobile();

      // keyboard handlers
      window.addEventListener("keydown", (e) => {
        keys[e.key.toLowerCase()] = true;
        if (!running && e.key === "Enter" && !paused && !mainMenu.hidden) {
          playBtn.click();
        }
      });
      window.addEventListener("keyup", (e) => {
        keys[e.key.toLowerCase()] = false;
      });

      // game input read
      function getInputDir() {
        let x = 0,
          y = 0;
        if (joystickActive) {
          x = joystick.x;
          y = joystick.y;
        } else {
          if (keys["w"] || keys["arrowup"]) y -= 1;
          if (keys["s"] || keys["arrowdown"]) y += 1;
          if (keys["a"] || keys["arrowleft"]) x -= 1;
          if (keys["d"] || keys["arrowright"]) x += 1;
        }
        // normalize
        let length = Math.sqrt(x * x + y * y);
        if (length > 0) {
          x /= length;
          y /= length;
        }
        return { x, y };
      }

      // update player position
      function updatePlayer() {
        if (paused || !running) return;
        const dir = getInputDir();
        player.x += dir.x * player.speed;
        player.y += dir.y * player.speed;
        player.x = clamp(player.x, 0, W - player.size);
        player.y = clamp(player.y, 0, H - player.size);
      }

      // UI update
      function updateUI() {
        healthSpan.textContent = player.health;
        scoreSpan.textContent = Math.floor(score);
        coinsSpan.textContent = coins;
        difficultyText.textContent = difficulty;
      }

      // spawn enemies & particles based on difficulty timing
      function gameTick(time) {
        if (!lastTime) lastTime = time;
        const delta = time - lastTime;
        lastTime = time;

        if (paused || !running) {
          requestAnimationFrame(gameTick);
          return;
        }

        // spawn enemies timer
        scaleTimer += delta;
        if (scaleTimer > difficulties[difficulty].spawn) {
          spawnEnemy();
          scaleTimer = 0;
        }
        // spawn particles a bit more often
        if (Math.random() < 0.3) spawnParticle();

        updatePlayer();
        updateEnemies();
        updateParticles();
        updateFragments();

        // update score
        lastScoreTick += delta;
        if (lastScoreTick > 1000) {
          score += difficulties[difficulty].scorePerSec;
          lastScoreTick = 0;

          // add coins every 10 score points
          let newCoins = Math.floor(score / 10) - coins;
          if (newCoins > 0) {
            coins += Math.min(newCoins, 20); // limit max 20 coins per second to prevent inflation
          }
        }

        updateUI();
        draw();
        requestAnimationFrame(gameTick);
      }

      // draw all
      function draw() {
        ctx.clearRect(0, 0, W, H);

        // white particles left moving 50% transparent
        drawParticles();

        // enemies top->down
        drawEnemies();

        // player or fragments if dead
        if (fragments.length > 0) {
          drawFragments();
        } else {
          drawPlayer();
        }
      }

      // death logic
      function onPlayerDeath() {
        running = false;
        paused = true;
        createFragments();
        showDeathFlash();

        // save coins and score earned
        const coinsEarned = Math.floor(coins);

        // show death menu after fragments fade out
        setTimeout(() => {
          deathMenu.style.display = "flex";
          deathMenu.classList.add("fade-in");
          finalScore.textContent = `score: ${Math.floor(score)}`;
          finalCoins.textContent = `coins earned: ${coinsEarned}`;
          coins += coinsEarned;
          saveGame();
          ui.style.display = "none";
          pauseBtn.style.display = "none";
        }, 800);
      }

      // reset game to start playing
      function resetGame() {
        player.health = Math.floor(maxPlayerHealth() * difficulties[difficulty].healthMult);
        player.x = W / 2 - player.size / 2;
        player.y = H - player.size * 3;
        enemies = [];
        particles = [];
        fragments = [];
        score = 0;
        lastSpawn = 0;
        scaleTimer = 0;
        paused = false;
        running = true;
        ui.style.display = "block";
        pauseBtn.style.display = "block";
        deathMenu.style.display = "none";
        deathOverlay.classList.remove("hit");
        updateUI();
      }

      // pause toggle
      pauseBtn.addEventListener("click", () => {
        if (!running) return;
        paused = !paused;
        pauseBtn.textContent = paused ? "resume" : "pause";
        pauseBtn.setAttribute("aria-pressed", paused.toString());
      });

      // main menu difficulty buttons highlight
      function updateDiffButtons() {
        diffBtns.forEach((btn) => {
          btn.classList.toggle("selected", btn.dataset.difficulty === difficulty);
        });
        difficultyText.textContent = difficulty;
      }

      // difficulty select handler
      diffBtns.forEach((btn) => {
        btn.addEventListener("click", () => {
          difficulty = btn.dataset.difficulty;
          localStorage.setItem(KEY_DIFF, difficulty);
          updateDiffButtons();
          playBtn.disabled = false;
        });
      });

      updateDiffButtons();

      // play button
      playBtn.addEventListener("click", () => {
        mainMenu.style.display = "none";
        resetGame();
        requestAnimationFrame(gameTick);
      });

      // restart button
      restartBtn.addEventListener("click", () => {
        deathMenu.style.display = "none";
        resetGame();
        requestAnimationFrame(gameTick);
      });

      // main menu button from death menu
      mainMenuBtn.addEventListener("click", () => {
        deathMenu.style.display = "none";
        mainMenu.style.display = "flex";
        ui.style.display = "none";
        pauseBtn.style.display = "none";
      });

      // store logic
      function updateStoreUI() {
        coinsDisplay.textContent = `coins: ${coins}`;
      }

      function renderStoreItems() {
        itemsList.innerHTML = "";
        skins.forEach((skin) => {
          const owned = ownedSkins.includes(skin.id);
          const selected = selectedSkin === skin.id;
          const item = document.createElement("div");
          item.className = "itemCard";
          if (owned) item.classList.add("owned");
          if (selected) item.classList.add("selected");
          item.innerHTML = `
            <div class="swatch" style="background-color:${skin.color};"></div>
            <strong>${skin.name}</strong>
            <div style="font-size:14px;color:#a0f0a0;margin-bottom:8px;">${skin.desc}</div>
            <button ${owned ? (selected ? "disabled" : "") : ""}>${owned ? (selected ? "selected" : "select") : `buy: ${skin.price}c`}</button>
          `;
          const btn = item.querySelector("button");
          btn.addEventListener("click", () => {
            if (owned) {
              // select skin
              selectedSkin = skin.id;
              saveGame();
              renderStoreItems();
            } else {
              if (coins >= skin.price) {
                coins -= skin.price;
                ownedSkins.push(skin.id);
                selectedSkin = skin.id;
                saveGame();
                updateStoreUI();
                renderStoreItems();
              } else {
                alert("not enough coins!");
              }
            }
          });
          itemsList.appendChild(item);
        });

        // powerups
        powerups.forEach((pwr) => {
          const owned = ownedPowerups.includes(pwr.id);
          const item = document.createElement("div");
          item.className = "itemCard";
          if (owned) item.classList.add("owned");
          item.innerHTML = `
            <strong>${pwr.name}</strong>
            <div style="font-size:14px;color:#a0f0a0;margin-bottom:8px;">${pwr.desc}</div>
            <button ${owned ? "disabled" : ""}>${owned ? "owned" : `buy: ${pwr.price}c`}</button>
          `;
          const btn = item.querySelector("button");
          btn.addEventListener("click", () => {
            if (!owned) {
              if (coins >= pwr.price) {
                coins -= pwr.price;
                ownedPowerups.push(pwr.id);
                saveGame();
                updateStoreUI();
                renderStoreItems();
              } else {
                alert("not enough coins!");
              }
            }
          });
          itemsList.appendChild(item);
        });
      }

      openStoreBtn.addEventListener("click", () => {
        mainMenu.style.display = "none";
        storeScreen.style.display = "flex";
        updateStoreUI();
        renderStoreItems();
      });

      closeStore.addEventListener("click", () => {
        storeScreen.style.display = "none";
        mainMenu.style.display = "flex";
      });

      // show pause button only in game
      function showPauseBtn(show) {
        pauseBtn.style.display = show ? "block" : "none";
      }

      // start on main menu
      ui.style.display = "none";
      pauseBtn.style.display = "none";

      // load saved data
      loadGame();

      updateDiffButtons();
      playBtn.disabled = false;

      // move player initial position
      player.x = W / 2 - player.size / 2;
      player.y = H - player.size * 3;

    })();
  </script>
</body>
</html>
